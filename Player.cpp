#include "Player.hpp"
#include <random>
#include <iostream>
#define PLAYERSPEED 50
#define HITEDTIMER 1.1
#define ANIMTIMER 0.2


int Player::actualHat() const { return _actualHat; }

void Player::setActualHat(int actualHat) { _actualHat = actualHat; }

int Player::getHP() const { return _hp; }

void Player::setHP(int helthPoints) { _hp = helthPoints; }

bool Player::hitted() const{    return _hitted;}

void Player::setHitted(bool hitted){ _hitted = hitted; }

float Player::hittedTimer() const{ return _hittedTimer; }

void Player::setHittedTimer(float hittedTimer){ _hittedTimer = hittedTimer; }

Player::Player(): body(40,100), guide(10,100){
    _hp = 5;
    angle = 0;
    _index = 0;
    radius = 35;
    _actualHat = 0;
    lastUpdate = 0;
    speed = PLAYERSPEED;

    hooking = false;
    hookPos.x = hookPos.y = 1;
    hook.setOrigin(hookPos);
    hook.setDestiny(hookPos);

    vel.x = vel.y = 0.01;
    cameraPos = mousePos = sf::Vector2f(0,0);

    body.setColor(sf::Color(100,100,100));
    guide.setColor(sf::Color(100,100,100));
    hook.setTexture(std::string(TEXTURETPATH)+("hook.png"));
    _destroyAnim = &Resources::destroyPlayer;

}


sf::Vector2f colisionPoint(sf::Vector2f /*pos*/, sf::Vector2f /*lpos*/){
    return sf::Vector2f(-1,-1);
}

void Player::setDistantHookPos(sf::Vector2i mousePos, Background* bg){

    sf::Vector2i intersection = bg->getIntersection(sf::Vector2i(getPosition()), mousePos);
    if(intersection.x == 1 && intersection.y == 1) {
        intersection.x = getPosition().x;
        intersection.y = getPosition().y;
    }
    setHookPos(sf::Vector2f(intersection.x, intersection.y));

}

float Player::getRadius() const{ return radius; }

void Player::updateHits(float deltaTime){
    if(_hitted){
        _hittedTimer += deltaTime;
        if(_hittedTimer >= HITEDTIMER){
            _hitted = false;
            _hittedTimer = 0.0;
        }
    }
}

void Player::updateSprite(){

     hat.setTexture((*_destroyAnim)[_index],true);

    if(_animTimer.getElapsedTime().asSeconds() > ANIMTIMER){
        ++_index;
        if( _index > _destroyAnim->size() ) {
            _destroying = false; _index = 0;
            _hp = 5;
            hat.setTexture(Resources::none[0]);
        }
        _animTimer.restart();
    }
}

void Player::update(float deltaTime, sf::Vector2i auxMousePos, Background* bg) {

    _destroying = (_hp <= 0);
    if(_destroying){
            updateSprite();
            return;
    }

    mousePos.x = auxMousePos.x;
    mousePos.y = auxMousePos.y;

    float dX = mousePos.x-getPos().x;
    float dY = mousePos.y-getPos().y;
    angle = std::atan2(dY,dX)*180/M_PI;

    extern int hardmode;
    if((! jumping) && (!hardmode) &&
           (InputManager::action(InputAction::up) > 0 ||
            InputManager::action(InputAction::movementY) < -0.5)
            ){
        vel.y = -constant::playerJump*deltaTime;
        jumping = true;
    }

    if( InputManager::action(InputAction::down) > 0){
        //cry me a river
    }
    if(InputManager::action(InputAction::left) > 0 ||
            InputManager::action(InputAction::movementX) < -0.5){
        vel.x -= constant::playerSpeed*deltaTime;
    }
    if(InputManager::action(InputAction::right) > 0 ||
            InputManager::action(InputAction::movementX) > 0.5){
        vel.x += constant::playerSpeed*deltaTime;
    }
    if( InputManager::action(InputAction::hook) > 0){
       if(!hooking)setDistantHookPos(auxMousePos, bg);
       hooking = true;
    } else {
       hooking = false;
       hookPos = mousePos;
    }
    if( InputManager::action(InputAction::shoot) > 0){

    }

    //Add gravity to the y speed
    vel.y += constant::gravity * deltaTime;


    //Add velocity generated by the hook to the player
    if(hooking){
        float deltaX = getHookPos().x-getPos().x;
        float deltaY = getHookPos().y-getPos().y;
        float angle = std::atan(deltaY / deltaX)*180/M_PI;
        float mod = std::sqrt(std::pow(deltaX,2) + std::pow(deltaY,2));
        if(deltaX >= 0) vel.x += std::cos(angle*M_PI/180) * mod * constant::hookForce *deltaTime;
        else vel.x -= std::cos(angle*M_PI/180) * mod * constant::hookForce * deltaTime;
        if(deltaY >= 0) vel.y += std::abs(std::sin(angle*M_PI/180)) * mod * constant::hookForce * deltaTime;
        else vel.y -= std::abs(std::sin(angle*M_PI/180)) * mod * constant::hookForce * deltaTime;
    }


    //Check that the speed on y is not higher than the maximum speed
    if(vel.y > 2*constant::playerMaxSpeed) vel.y = 2*constant::playerMaxSpeed;
    if(vel.y < -2*constant::playerMaxSpeed) vel.y = -2*constant::playerMaxSpeed;
    if(vel.x > 1.6*constant::playerMaxSpeed) vel.x = 1.6*constant::playerMaxSpeed;
    if(vel.x < -1.6*constant::playerMaxSpeed) vel.x = -1.6*constant::playerMaxSpeed;


    //Check COLISIONS
    sf::Vector2f orig = pos;
    sf::Vector2f dest = pos + vel;
    float rad = radius; bool stopX = false;

   // float aux = sqrt( (rad*rad)/2 );
    float aux = std::sin(45)*rad;


    //check Y
    if(! bg->rectangleColision(sf::FloatRect(orig.x-aux, dest.y-aux, 2*aux, 2*aux))){
        pos.y = dest.y;
        if(vel.x > 0) vel.x -= constant::friction/3 * deltaTime;
        if(vel.x < 0) vel.x += constant::friction/3 * deltaTime;
    }
    else {//THERE IS A COLISION ON Y
        if(vel.y > 0) jumping = false;
        vel.y = 0;
        vel.x -= vel.x/1.7  * deltaTime;
        if(vel.x > 0) vel.x -= constant::friction * deltaTime;
        if(vel.x < 0) vel.x += constant::friction * deltaTime;
    }

    //check X
    if(! bg->rectangleColision(sf::FloatRect(dest.x-aux, pos.y-aux, 2*aux, 2*aux))){
        pos.x = dest.x;
        orig.x = dest.x;
    }
    else {//THERE IS A COLISION ON X
        stopX = true;
    }

    setPosition(pos);

    if (stopX) vel.x = 0;

    getSpeed();
    updateHits(deltaTime);

}

void Player::hit(int damage){
    if(!_hitted && !_destroying) {
        _hp -= damage;
        _hitted = true;
    }
}

bool Player::isDead(){
    return _hp <= 0 && _index >= _destroyAnim->size();
}

float Player::getSpeed() const { return speed; }
void Player::setSpeed(float value) { speed = value; }

sf::Vector2f Player::getHookPos() const { return hookPos; }

sf::Vector2f Player::getMousePos() const { return mousePos; }
void Player::setMousePos(const sf::Vector2f &value) { mousePos = value;}

sf::Vector2f Player::getPos() const { return pos; }

void Player::setPos(const sf::Vector2f &value) { pos = value; /*log("setPos");*/}

sf::Vector2f Player::getPosition() { return body.getPosition(); }

sf::Vector2f Player::getGuidePosition() { return guide.getPosition(); }

void Player::draw(sf::RenderTarget * w){
    sf::Vector2f guiaPos;
    guiaPos.x = body.getPosition().x + std::cos(angle*M_PI/180) * (body.getRadius() + guide.getRadius() + 10);
    guiaPos.y = body.getPosition().y + std::sin(angle*M_PI/180) * (body.getRadius() + guide.getRadius() + 10);
    guide.setPosition(guiaPos);

    sf::Vector2f hatpos;
    float anglehat = -(90+35);
    hatpos.x = body.getPosition().x + std::cos(anglehat*M_PI/180) * (body.getRadius());
    hatpos.y = body.getPosition().y + std::sin(anglehat*M_PI/180) * (body.getRadius())+ (vel.y*-3 * (vel.y > 0));
    hat.setRotation(-1*vel.x);
    hat.setPosition(hatpos);

    if(hooking) hook.draw(w);
    body.draw(w);
    eyes.draw(w);
    if(hitted()){
        float aux = hittedTimer();
        Resources::cInvert.setParameter("deltaTime", aux);
        if (int(aux*10) %3 != 0) {
            w->draw(hat,&Resources::cInvert);
        }else {
            w->draw(hat);
        }
    }else {
        w->draw(hat);
    }
    guide.draw(w);

    if(DEBUGDRAW){
        sf::CircleShape O;
        O.setRadius(guide.getRadius());
        O.setOrigin(guide.getRadius(),guide.getRadius());
        O.setPosition(guiaPos);
        O.setFillColor(sf::Color(255,255,255,120));
        O.setOutlineColor(sf::Color(100,0,0,120));
        O.setOutlineThickness(5);
        w->draw(O);
        O.setRadius(body.getRadius());
        O.setOrigin(body.getRadius(), body.getRadius());
        O.setPosition(body.getPosition());
        w->draw(O);
        sf::RectangleShape bbox;
        bbox.setPosition(body.getPosition().x-29.78,
                         body.getPosition().y-29.78);
        bbox.setSize(sf::Vector2f(2*29.78,2*29.78));
        bbox.setFillColor(sf::Color(255,0,0,120));
        bbox.setOutlineThickness(0);
        w->draw(bbox);
        sf::RectangleShape box;
        box.setOrigin(hat.getOrigin());
        box.setRotation(hat.getRotation());
        box.setPosition(hat.getPosition());
        box.setFillColor(sf::Color(0,100,0,100));
        box.setSize(sf::Vector2f(hat.getGlobalBounds().width, hat.getGlobalBounds().height));
        w->draw(box);
    }
}

void Player::moveOut(float speed){
    vel.x = vel.y = 0;
    setPosition(sf::Vector2f(getPosition().x+speed, getPosition().y));
}

void Player::setPosition(const sf::Vector2f pos){
    hook.setOrigin(pos);
    body.setPosition(pos);

    //EYES
    sf::Vector2f eyesPos;
    eyesPos.x = body.getPosition().x + std::cos(angle*M_PI/180) * (body.getRadius() - eyes.getSize().x/1.5);
    eyesPos.y = body.getPosition().y + std::sin(angle*M_PI/180) * (body.getRadius() - eyes.getSize().y);
    eyes.setSize(body.getRadius()*3/5,body.getRadius()*3/5);
    eyes.setPosition(eyesPos);

    sf::Vector2f guiaPos;
    guiaPos.x = body.getPosition().x + std::cos(angle*M_PI/180) * (body.getRadius() + guide.getRadius()*2);
    guiaPos.y = body.getPosition().y + std::sin(angle*M_PI/180) * (body.getRadius() + guide.getRadius()*2);
    guide.setPosition(guiaPos);
    this->pos = pos;
}

void Player::setAngle(float a){ angle = a; }

void Player::setHookPos(sf::Vector2f pos){
    hookPos = pos;
    hook.setDestiny(pos);
}

void Player::setHat(sf::Sprite& spr) {
    hat.setTexture((*spr.getTexture()),true);
    hat.setOrigin(hat.getLocalBounds().width/2, hat.getLocalBounds().height/2);
}

void Player::setHookPos(float posX, float posY) { hookPos.x = posX; hookPos.y = posY; hook.setDestiny(sf::Vector2f(posX,posY)); }

void Player::setPosition(float posX, float posY){ setPosition(sf::Vector2f(posX, posY)); }

