#include "Player.hpp"
#include <random>
#include <iostream>

Player::Player(): body(30,60), guide(10,60){
    angle = 0;
    radius = 20;
    lastUpdate = 0;
    hooking = false;
    vel.x = vel.y = 0;
    cameraPos = mousePos = sf::Vector2f(0,0);
    eyes.setTexture();
}


sf::Vector2f colisionPoint(sf::Vector2f pos, sf::Vector2f lpos){
/*
    //Take parameters

    Map* map = _map;
    sf::Vector2f position = pos;
    sf::Vector2f lookPosition = lpos;

    //Generate functions

    //y = mx + n
    //x = (y - n)/m
    //Ax + By + C = 0
    float m = (-lookPosition.y - -position.y) / 0.1;
    if((lookPosition.x - position.x) != 0)
        m = (-lookPosition.y - -position.y) / ((lookPosition.x - position.x));
    float A = -(-lookPosition.y - -position.y);
    float B = (lookPosition.x - position.x);
    float C = -B*(-position.y) - -A*-(position.x);
    float n = -C/B;

    //Define auxiliar variables
    int offsetX = 1;
    int offsetY = -1;
    int growDirectionX = 1;
    int growDirectionY = -1;

    bool colision = false;
    bool colisioningOnX = true;

    float Y = position.y - ( ((int)position.y % (int)constant::tileSize));
    float X = position.x + (constant::tileSize - ((int)position.x % (int)constant::tileSize));

    //Set auxiliar variables by case

    if(lookPosition.x < position.x) { offsetX = -1;growDirectionX = -1; X -= constant::tileSize;}
    if(lookPosition.y > position.y) { offsetY = 1;  growDirectionY = 1; Y += constant::tileSize;}

    if(growDirectionY == 1 && (-(m*X + n)) > Y) colisioningOnX = false;
    if(growDirectionY == -1 && (-(m*X + n)) < Y) colisioningOnX = false;
    if(std::abs(position.y - lookPosition.y) <= constant::tileSize) colisioningOnX = true;
    if(std::abs(position.x - lookPosition.x) <= constant::tileSize) colisioningOnX = false;

    //While you have not found the colision
    while( ! colision ){

        if(colisioningOnX){ //if colision is on X
            float pointOnY = -(m*X + n) ;
            if( ! map->isColisionable(X+offsetX,pointOnY)){
                X += constant::tileSize * growDirectionX;
                if (growDirectionY == 1 && (-(m*X + n) > Y)) colisioningOnX = false;
                else if (growDirectionY == -1 && (-(m*X + n) < Y)) colisioningOnX = false;
            }
            else {
                colision = true;
                return(sf::Vector2f(X, pointOnY));
            }
        }
        else {              //if colisioning On Y
            float pointOnX = ((-Y)-n)/m;
            if( ! map->isColisionable(pointOnX, Y+offsetY) ){
                Y += constant::tileSize * growDirectionY;
                if (growDirectionX == 1 &&  (((-Y)-n)/m > X )) colisioningOnX = true;
                else if (growDirectionX == -1 &&  (((-Y)-n)/m < X )) colisioningOnX = true;
            }
            else {
                colision = true;
                return(sf::Vector2f(pointOnX, Y));
            }
        }
    }
    return sf::Vector2f(-1,-1);// Si llega aquÃ­ se ha roto :(
*/
}

void Player::setDistantHookPos(){
   /* Map* map = server->getMap();
    sf::Vector2f position = getPos();
    sf::Vector2f lookPosition = getLookPos();
    setHookPos(colisionPoint(position, lookPosition, map));*/
}

void Player::update(float deltaTime) {


    sf::Vector2i auxMousePos;
    auxMousePos = sf::Mouse::getPosition();
    mousePos.x = auxMousePos.x;
    mousePos.y = auxMousePos.y;

    if( InputManager::action(InputAction::up) > 0){
        vel.y = -constant::playerJump*deltaTime;
    }
    if( InputManager::action(InputAction::down) > 0){
        pos.y = 0; pos.x = 0;
    }
    if( InputManager::action(InputAction::left) > 0){
        vel.x -= speed*deltaTime;
    }
    if( InputManager::action(InputAction::right) > 0){
        vel.x += speed*deltaTime;
    }

/*    if(!hooking){
        setDistantHookPos();
        hooking = true;
    }
    setHookPos(getPos());
    hooking = false;
*/
    //Add gravity to the y speed
    vel.y += constant::gravity * deltaTime;

    //Add velocity generated by the hook to the player
 /*   if(hooking){
        float deltaX = getHookPos().x-getPos().x;
        float deltaY = getHookPos().y-getPos().y;
        float angle = std::atan(deltaY / deltaX)*180/M_PI;
        float mod = std::sqrt(std::pow(deltaX,2) + std::pow(deltaY,2));
        if(deltaX >= 0) vel.x += std::cos(angle*M_PI/180) * mod * constant::hookForce *deltaTime;
        else vel.x -= std::cos(angle*M_PI/180) * mod * constant::hookForce * deltaTime;
        if(deltaY >= 0) vel.y += std::abs(std::sin(angle*M_PI/180)) * mod * constant::hookForce * deltaTime;
        else vel.y -= std::abs(std::sin(angle*M_PI/180)) * mod * constant::hookForce * deltaTime;
    }
*/
    //Check that the speed on y is not higher than the maximum speed
    if(vel.y > constant::playerMaxSpeed) vel.y = constant::playerMaxSpeed;
    if(vel.y < -1*constant::playerMaxSpeed) vel.y = -1*constant::playerMaxSpeed;


    //Check COLISIONS
    sf::Vector2f orig = pos;
    sf::Vector2f dest = pos + vel;
    float rad = radius; bool stopX = false;
    //CHECK on X
    /*if(        ! map->isColisionable(dest.x+rad, orig.y)
            && ! map->isColisionable(dest.x-rad, orig.y)
            && ! map->isColisionable(dest.x+rad, orig.y+rad)
            && ! map->isColisionable(dest.x+rad, orig.y-rad)
            && ! map->isColisionable(dest.x-rad, orig.y+rad)
            && ! map->isColisionable(dest.x-rad, orig.y-rad) ){
        pos.x = dest.x;
    }
    else {//THERE IS A COLISION ON X
        stopX = true;
    }*/
    //CHECK on Y
    /*if(        ! map->isColisionable(orig.x, dest.y+rad)
            && ! map->isColisionable(orig.x, dest.y-rad)
            && ! map->isColisionable(orig.x+rad, dest.y+rad)
            && ! map->isColisionable(orig.x+rad, dest.y-rad)
            && ! map->isColisionable(orig.x-rad, dest.y+rad)
            && ! map->isColisionable(orig.x-rad, dest.y-rad) ){
        pos.y = dest.y;
    }
    else {//THERE IS A COLISION ON Y
        vel.y = 0;
        vel.x -= vel.x/1.7  * deltaTime;

    }*/
    rad = radius;
    pos.x = dest.x;
    pos.y = dest.y;
    orig.x = orig.x;

    if(pos.y > 700) pos.y = 700;
    setPosition(pos);
    //If it colisioned on x stop movint on that axe
    //(is done now, not in the oclision because) we need the speed on x to check Y colisions.
    //if (stopX) vel.x = 0;
}

float Player::getSpeed() const { return speed; }
void Player::setSpeed(float value) { speed = value; }

sf::Vector2f Player::getHookPos() const { return hookPos; }
void Player::setHookPos(const sf::Vector2f &value){ hookPos = value; }

sf::Vector2f Player::getMousePos() const { return mousePos; }
void Player::setMousePos(const sf::Vector2f &value) { mousePos = value;}

sf::Vector2f Player::getPos() const { return pos; }

void Player::setPos(const sf::Vector2f &value) { pos = value; }
sf::Vector2f Player::getLookPos() const { sf::Vector2f ret = cameraPos+mousePos; return ret; }

sf::Vector2f Player::getPosition(){ return body.getPosition(); }

void Player::draw(sf::RenderTarget * w){
    sf::Vector2f guiaPos;
    guiaPos.x = body.getPosition().x + std::cos(angle*M_PI/180) * (body.getRadius() + guide.getRadius() + 10);
    guiaPos.y = body.getPosition().y + std::sin(angle*M_PI/180) * (body.getRadius() + guide.getRadius() + 10);
    guide.setPosition(guiaPos);

    hook.draw(w);
    body.draw(w);
    guide.draw(w);
    eyes.draw(w);
}


void Player::setPosition(sf::Vector2f pos){
    hook.setOrigin(pos);
    body.setPosition(pos);

    //EYES
    sf::Vector2f eyesPos;
    eyesPos.x = body.getPosition().x + std::cos(angle*M_PI/180) * (body.getRadius() - eyes.getSize().x/1.5);
    eyesPos.y = body.getPosition().y + std::sin(angle*M_PI/180) * (body.getRadius() - eyes.getSize().y);
    eyes.setSize(body.getRadius()*3/5,body.getRadius()*3/5);
    eyes.setPosition(eyesPos);

    sf::Vector2f guiaPos;
    guiaPos.x = body.getPosition().x + std::cos(angle*M_PI/180) * (body.getRadius() + guide.getRadius()*2);
    guiaPos.y = body.getPosition().y + std::sin(angle*M_PI/180) * (body.getRadius() + guide.getRadius()*2);
    guide.setPosition(guiaPos);
}

void Player::setAngle(float a){ angle = a; }

void Player::setHookPos(sf::Vector2f pos){ hook.setDestiny(pos); }

void Player::setHookPos(float posX, float posY) { hook.setDestiny(sf::Vector2f(posX,posY)); }

void Player::setPosition(float posX, float posY){ setPosition(sf::Vector2f(posX, posY)); }

