#include "Player.hpp"
#include <random>
#include <iostream>
#define PLAYERSPEED 50

Player::Player(): body(40,100), guide(10,100){
    angle = 0;
    speed = PLAYERSPEED;
    radius = 35;
    lastUpdate = 0;
    hooking = false;
    hookPos.x = hookPos.y = 1;
    hook.setOrigin(hookPos);
    hook.setDestiny(hookPos);
    vel.x = vel.y = 0.01;
    cameraPos = mousePos = sf::Vector2f(0,0);
    //eyes.setTexture();
    body.setColor(sf::Color(100,100,100));
    guide.setColor(sf::Color(100,100,100));
    hook.setTexture(std::string(TEXTURETPATH)+("hook.png"));
}


sf::Vector2f colisionPoint(sf::Vector2f pos, sf::Vector2f lpos){

}

void Player::setDistantHookPos(sf::Vector2i mousePos, Background* bg){

    sf::Vector2i intersection = bg->getIntersection(sf::Vector2i(getPosition()), mousePos);
    if(intersection.x == 1 && intersection.y == 1) {
        intersection.x = getPosition().x;
        intersection.y = getPosition().y;
    }
    setHookPos(sf::Vector2f(intersection.x, intersection.y));

}

float Player::getRadius() const{ return radius; }

void Player::update(float deltaTime, sf::Vector2i auxMousePos, Background* bg) {

    mousePos.x = auxMousePos.x;
    mousePos.y = auxMousePos.y;

    float dX = mousePos.x-getPos().x;
    float dY = mousePos.y-getPos().y;
    angle = std::atan2(dY,dX)*180/M_PI;

    if( InputManager::action(InputAction::up) > 0 && (! jumping) ){
        vel.y = -constant::playerJump*deltaTime;
        jumping = true;
    }
    if( InputManager::action(InputAction::down) > 0){
        //cry me a river
    }
    if( InputManager::action(InputAction::left) > 0){
        vel.x -= constant::playerSpeed*deltaTime;
    }
    if( InputManager::action(InputAction::right) > 0){
        vel.x += constant::playerSpeed*deltaTime;
    }
    if( InputManager::action(InputAction::hook) > 0){
       if(!hooking)setDistantHookPos(auxMousePos, bg);
       hooking = true;
       //std::cout << "auxmousepos " << auxMousePos.x << " , " << auxMousePos.y << std::endl;
    } else {
       hooking = false;
       hookPos = mousePos;
    }
    if( InputManager::action(InputAction::shoot) > 0){

    }

    //Add gravity to the y speed
    vel.y += constant::gravity * deltaTime;


    //Add velocity generated by the hook to the player
    if(hooking){
        float deltaX = getHookPos().x-getPos().x;
        float deltaY = getHookPos().y-getPos().y;
        float angle = std::atan(deltaY / deltaX)*180/M_PI;
        float mod = std::sqrt(std::pow(deltaX,2) + std::pow(deltaY,2));
        if(deltaX >= 0) vel.x += std::cos(angle*M_PI/180) * mod * constant::hookForce *deltaTime;
        else vel.x -= std::cos(angle*M_PI/180) * mod * constant::hookForce * deltaTime;
        if(deltaY >= 0) vel.y += std::abs(std::sin(angle*M_PI/180)) * mod * constant::hookForce * deltaTime;
        else vel.y -= std::abs(std::sin(angle*M_PI/180)) * mod * constant::hookForce * deltaTime;
    }


    //Check that the speed on y is not higher than the maximum speed
    if(vel.y > 2*constant::playerMaxSpeed) vel.y = 2*constant::playerMaxSpeed;
    if(vel.y < -2*constant::playerMaxSpeed) vel.y = -2*constant::playerMaxSpeed;
    if(vel.x > 1.6*constant::playerMaxSpeed) vel.x = 1.6*constant::playerMaxSpeed;
    if(vel.x < -1.6*constant::playerMaxSpeed) vel.x = -1.6*constant::playerMaxSpeed;


    //Check COLISIONS
    sf::Vector2f orig = pos;
    sf::Vector2f dest = pos + vel;
    float rad = radius; bool stopX = false;

    float aux = sqrt( (rad*rad)/2 );

    //CHECK on X

    bool colision = false;
    int COLISIONPRECISION = 50;
    float step = 360/COLISIONPRECISION;
    for(int s = 0; s < COLISIONPRECISION; ++s){
        if(bg->colision(dest.x+(std::cos(step*s)*rad),orig.y+(std::sin(step*s)*rad))) colision = true;
    }
    if(!colision && ! bg->colision(dest.x+rad, orig.y)
            && ! bg->colision(dest.x-rad, orig.y)
            && ! bg->colision(dest.x,     orig.y-rad)
            && ! bg->colision(dest.x,     orig.y+rad)
            && ! bg->colision(dest.x+aux, orig.y+aux)
            && ! bg->colision(dest.x+aux, orig.y-aux)
            && ! bg->colision(dest.x-aux, orig.y+aux)
            && ! bg->colision(dest.x-aux, orig.y-aux) ){
        pos.x = dest.x;
        orig.x = dest.x;
    }
    else {//THERE IS A COLISION ON X
        stopX = true;
    }
    //CHECK on Y
    colision = false;
    for(int s = 0; s < COLISIONPRECISION; ++s){
        if(bg->colision(orig.x+(std::cos(step*s)*rad),dest.y+(std::sin(step*s)*rad))) colision = true;
    }
    if( !colision &&       ! bg->colision(orig.x, dest.y+rad)
            && ! bg->colision(orig.x, dest.y-rad)
            && ! bg->colision(orig.x+rad, dest.y)
            && ! bg->colision(orig.x-rad, dest.y)
            && ! bg->colision(orig.x+aux, dest.y+aux)
            && ! bg->colision(orig.x+aux, dest.y-aux)
            && ! bg->colision(orig.x-aux, dest.y+aux)
            && ! bg->colision(orig.x-aux, dest.y-aux) ){
        pos.y = dest.y;
        if(vel.x > 0) vel.x -= constant::friction/3 * deltaTime;
        if(vel.x < 0) vel.x += constant::friction/3 * deltaTime;
    }
    else {//THERE IS A COLISION ON Y
        if(vel.y > 0) jumping = false;
        vel.y = 0;
        vel.x -= vel.x/1.7  * deltaTime;
        if(vel.x > 0) vel.x -= constant::friction * deltaTime;
        if(vel.x < 0) vel.x += constant::friction * deltaTime;
    }


   /***** sf::Vector2f toGoBack = bg->getVectorFromCircleColision(vel, dest, rad);
    pos = dest - toGoBack;******/

    setPosition(pos);
    //If it colisioned on x stop movint on that axe
    //(is done now, not in the oclision because) we need the speed on x to check Y colisions.
    //if(getPosition().y > 666) jumping = false;
    if (stopX) vel.x = 0;

    /*****
    if(bg->circleColision(dest, rad)){
        sf::Vector2f offset = bg->getCircleColisionOffset(dest,rad);
        if(offset.x != 0){
            pos.x = pos.x + (offset.x * (-1*(vel.x < 0)));
        }else pos.x = dest.x;
        if(offset.y != 0){
            pos.y = pos.y + (offset.y * (-1*(vel.y > 0)));
        }else pos.y = dest.y;
        setPosition(pos);
    }
    else setPosition(dest);
    ****/


}

float Player::getSpeed() const { return speed; }
void Player::setSpeed(float value) { speed = value; }

sf::Vector2f Player::getHookPos() const { return hookPos; }

sf::Vector2f Player::getMousePos() const { return mousePos; }
void Player::setMousePos(const sf::Vector2f &value) { mousePos = value;}

sf::Vector2f Player::getPos() const { return pos; }

void Player::setPos(const sf::Vector2f &value) { pos = value; log("setPos");}

sf::Vector2f Player::getPosition() { return body.getPosition(); }

void Player::draw(sf::RenderTarget * w){
    sf::Vector2f guiaPos;
    guiaPos.x = body.getPosition().x + std::cos(angle*M_PI/180) * (body.getRadius() + guide.getRadius() + 10);
    guiaPos.y = body.getPosition().y + std::sin(angle*M_PI/180) * (body.getRadius() + guide.getRadius() + 10);
    guide.setPosition(guiaPos);

    sf::Vector2f hatpos;
    float anglehat = -(90+35);
    hatpos.x = body.getPosition().x + std::cos(anglehat*M_PI/180) * (body.getRadius());
    hatpos.y = body.getPosition().y + std::sin(anglehat*M_PI/180) * (body.getRadius())+ (vel.y*-3 * (vel.y > 0));
    hat.setRotation(-1*vel.x);
    hat.setPosition(hatpos);

    if(hooking) hook.draw(w);
    body.draw(w);
    eyes.draw(w);
    w->draw(hat);
    guide.draw(w);
}

void Player::moveOut(float speed){
    vel.x = vel.y = 0;
    setPosition(sf::Vector2f(getPosition().x+speed, getPosition().y));
}

void Player::setPosition(const sf::Vector2f pos){
    hook.setOrigin(pos);
    body.setPosition(pos);

    //EYES
    sf::Vector2f eyesPos;
    eyesPos.x = body.getPosition().x + std::cos(angle*M_PI/180) * (body.getRadius() - eyes.getSize().x/1.5);
    eyesPos.y = body.getPosition().y + std::sin(angle*M_PI/180) * (body.getRadius() - eyes.getSize().y);
    eyes.setSize(body.getRadius()*3/5,body.getRadius()*3/5);
    eyes.setPosition(eyesPos);

    sf::Vector2f guiaPos;
    guiaPos.x = body.getPosition().x + std::cos(angle*M_PI/180) * (body.getRadius() + guide.getRadius()*2);
    guiaPos.y = body.getPosition().y + std::sin(angle*M_PI/180) * (body.getRadius() + guide.getRadius()*2);
    guide.setPosition(guiaPos);
    this->pos = pos;
}

void Player::setAngle(float a){ angle = a; }

void Player::setHookPos(sf::Vector2f pos){
    hookPos = pos;
    hook.setDestiny(pos);
}

void Player::setHat(sf::Sprite& spr) {
    hat.setTexture((*spr.getTexture()),true);
    hat.setOrigin(hat.getLocalBounds().width/2, hat.getLocalBounds().height/2);
}

void Player::setHookPos(float posX, float posY) { hookPos.x = posX; hookPos.y = posY; hook.setDestiny(sf::Vector2f(posX,posY)); }

void Player::setPosition(float posX, float posY){ setPosition(sf::Vector2f(posX, posY)); }

